# Rive ViewModel Generator

A Flutter application that generates Dart view model classes from Rive files. This tool helps you create type-safe view models for your Rive animations, making it easier to interact with Rive state machines in your Flutter applications.

## Demo

https://github.com/user-attachments/assets/d68f36da-c244-4274-aa08-ed38528e6555

Check out the live demo at [tguerin.github.io/rive-viewmodel-generator](https://tguerin.github.io/rive-viewmodel-generator)

## Features

- Drag and drop interface for Rive files
- Generates type-safe Dart view model classes
- Supports all Rive property types (boolean, number, string, color, trigger, enum, nested view model)
- Support Artboards and StateMachines generation
- Generates stream getters for reactive programming
- Works on both web and desktop platforms
- Multiple file processing
- File history with download capabilities

## Usage

1. Open the application
2. Drag and drop your `.riv` file(s) onto the drop zone
3. The application will generate a Dart view model class for each Rive file
4. Download the generated files using the download button next to each file
5. Use the generated view model in your Flutter application

## Generated Code Example

Here's an example of a generated view model class:

```dart
// This file was generated by rive_viewmodel_generator
// Do not edit this file manually
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: unused_import
import 'dart:async';
import 'dart:ui';
import 'package:rive_native/rive_native.dart';

enum Orientation { portrait, landscape }

enum ArtboardStateMachine {
  stateMachine1('State Machine 1');

  const ArtboardStateMachine(this.name);
  final String name;
}

sealed class _SealedArtboard {
  String get name;
}

abstract interface class TestArtboard {
  static const artboard = _Artboard();
}

class _Artboard implements _SealedArtboard {
  const _Artboard();

  @override
  String get name => 'Artboard';

  ArtboardStateMachine get stateMachine1 => ArtboardStateMachine.stateMachine1;
}

class NestedViewModel {
  NestedViewModel._(this._viewModel);

  factory NestedViewModel.fromViewModel(ViewModelInstance viewModel) =
      NestedViewModel._;

  final ViewModelInstance _viewModel;

  final Map<String, StreamController<dynamic>> _streamControllers = {};

  double get numberProperty => _viewModel.number('numberProperty')!.value;

  set numberProperty(double value) =>
      _viewModel.number('numberProperty')!.value = value;

  Stream<double> get numberPropertyStream {
    return (_streamControllers['numberProperty'] ??= () {
          final controller = StreamController<double>.broadcast();
          _streamControllers['numberProperty'] = controller;
          final property = _viewModel.number('numberProperty')!;
          void valueListener(double value) => controller.add(value);
          void onListen() => property.addListener(valueListener);
          void onCancel() => property.removeListener(valueListener);
          controller
            ..onListen = onListen
            ..onCancel = onCancel;
          return controller;
        }()).stream
        as Stream<double>;
  }

  void bind(StateMachine stateMachine) =>
      stateMachine.bindViewModelInstance(_viewModel);

  void dispose() {
    for (final controller in _streamControllers.values) {
      controller.close();
    }
    _streamControllers.clear();
    _viewModel.dispose();
  }
}

class TestViewModel {
  TestViewModel._(this._viewModel);

  factory TestViewModel.fromViewModel(ViewModelInstance viewModel) =
      TestViewModel._;

  final ViewModelInstance _viewModel;

  final Map<String, StreamController<dynamic>> _streamControllers = {};

  NestedViewModel get nestedViewModel {
    return NestedViewModel.fromViewModel(
      _viewModel.viewModel('nestedViewModel')!,
    );
  }

  double get numberProperty => _viewModel.number('numberProperty')!.value;

  set numberProperty(double value) =>
      _viewModel.number('numberProperty')!.value = value;

  Stream<double> get numberPropertyStream {
    return (_streamControllers['numberProperty'] ??= () {
          final controller = StreamController<double>.broadcast();
          _streamControllers['numberProperty'] = controller;
          final property = _viewModel.number('numberProperty')!;
          void valueListener(double value) => controller.add(value);
          void onListen() => property.addListener(valueListener);
          void onCancel() => property.removeListener(valueListener);
          controller
            ..onListen = onListen
            ..onCancel = onCancel;
          return controller;
        }()).stream
        as Stream<double>;
  }

  void triggerProperty() => _viewModel.trigger('triggerProperty')!.trigger();

  Color get colorProperty => _viewModel.color('colorProperty')!.value;

  set colorProperty(Color value) =>
      _viewModel.color('colorProperty')!.value = value;

  Stream<Color> get colorPropertyStream {
    return (_streamControllers['colorProperty'] ??= () {
          final controller = StreamController<Color>.broadcast();
          _streamControllers['colorProperty'] = controller;
          final property = _viewModel.color('colorProperty')!;
          void valueListener(Color value) => controller.add(value);
          void onListen() => property.addListener(valueListener);
          void onCancel() => property.removeListener(valueListener);
          controller
            ..onListen = onListen
            ..onCancel = onCancel;
          return controller;
        }()).stream
        as Stream<Color>;
  }

  bool get booleanProperty => _viewModel.boolean('booleanProperty')!.value;

  set booleanProperty(bool value) =>
      _viewModel.boolean('booleanProperty')!.value = value;

  Stream<bool> get booleanPropertyStream {
    return (_streamControllers['booleanProperty'] ??= () {
          final controller = StreamController<bool>.broadcast();
          _streamControllers['booleanProperty'] = controller;
          final property = _viewModel.boolean('booleanProperty')!;
          void valueListener(bool value) => controller.add(value);
          void onListen() => property.addListener(valueListener);
          void onCancel() => property.removeListener(valueListener);
          controller
            ..onListen = onListen
            ..onCancel = onCancel;
          return controller;
        }()).stream
        as Stream<bool>;
  }

  String get stringProperty => _viewModel.string('stringProperty')!.value;

  set stringProperty(String value) =>
      _viewModel.string('stringProperty')!.value = value;

  Stream<String> get stringPropertyStream {
    return (_streamControllers['stringProperty'] ??= () {
          final controller = StreamController<String>.broadcast();
          _streamControllers['stringProperty'] = controller;
          final property = _viewModel.string('stringProperty')!;
          void valueListener(String value) => controller.add(value);
          void onListen() => property.addListener(valueListener);
          void onCancel() => property.removeListener(valueListener);
          controller
            ..onListen = onListen
            ..onCancel = onCancel;
          return controller;
        }()).stream
        as Stream<String>;
  }

  Orientation get orientation => Orientation.values.firstWhere(
    (e) => e.name == _viewModel.enumerator('orientation')!.value,
  );

  set orientation(Orientation value) =>
      _viewModel.enumerator('orientation')!.value = value.name;

  Stream<Orientation> get orientationStream {
    return (_streamControllers['orientation'] ??= () {
          final controller = StreamController<Orientation>.broadcast();
          _streamControllers['orientation'] = controller;
          final property = _viewModel.enumerator('orientation')!;
          void valueListener(String value) => controller.add(
            Orientation.values.firstWhere((e) => e.name == value),
          );
          void onListen() => property.addListener(valueListener);
          void onCancel() => property.removeListener(valueListener);
          controller
            ..onListen = onListen
            ..onCancel = onCancel;
          return controller;
        }()).stream
        as Stream<Orientation>;
  }

  void bind(StateMachine stateMachine) =>
      stateMachine.bindViewModelInstance(_viewModel);

  void dispose() {
    for (final controller in _streamControllers.values) {
      controller.close();
    }
    _streamControllers.clear();
    _viewModel.dispose();
  }
}
```

## Important Notes

1. **Enum Properties**: Properties that use enums must end with the enum name. For example:
   - Valid: `playerOrientation`, `gameState`, `menuOrientation`
   - Invalid: `orientationPlayer`, `stateGame`

2. **Generated Files**: Each generated file includes:
   - Type-safe getters and setters for all properties
   - Stream getters for reactive programming
   - Proper cleanup with dispose method
   - Factory constructor for easy instantiation

3. **Usage in Flutter**:
```dart
final viewModel = TestViewModel.fromViewModel(stateMachine.viewModel('Test'));
// Use getters and setters
viewModel.orientation = Orientation.portrait;
// Listen to changes
viewModel.orientationStream.listen((orientation) {
  print('Orientation changed to: $orientation');
});
```

## Requirements

- Flutter 3.29.0 or higher
- Dart SDK 3.7.0 or higher

## License

This project is licensed under the BSD-3 License - see the [LICENSE](LICENSE) file for details.
